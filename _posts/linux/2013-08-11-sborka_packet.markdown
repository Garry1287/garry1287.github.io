---
layout: post
title:  "sborka_packet"
date:   2013-08-11 03:42:41 +0400
categories: linux
tags: linux
---

# sborka_packet
На деле при установке из исходников лучше выполнять следующее:
./configure && make && sudo checkinstall
Отличие от описанного ./configure && make && make install в том, что после make собирается deb-пакет, который сразу же устанавливается. После checkinstall пакет находится в текущем каталоге и может быть использован для повторной установки. Кроме того при создании пакета (внимательно читаем что пишут в консоли) если возможность указать зависимости, что так же заметно облегчает жизнь при повторной установке.

Плюсы такого подхода в том, что установленные приложения управляются Synaptic/aptitude и не требуют исходников для удаления (make uninstall).

Кроме того существует утилита dpkg-buildpackage, предназначенная уже больше для разработчиков. Мануал к ней можно найти тут: [http://www.penguin-soft.com/penguin/man/1/dpkg-source.html](http://www.penguin-soft.com/penguin/man/1/dpkg-source.html) 

checkinstal — это фактически make install в fakeroot с записью действий и последующей сборкой пакета. Этакий quick&dirty для сборки пакетов





 Пример:
Нужно протестировать новую версию ПО, которого нет в репах, но уже есть у разработчика.
Варианты:
1. Можно поставить его в /opt обычным make install двумя командами и одной удалить.
2. Можно выпендриться с созданием пакета и ставить все в живую систему при этом не имея гарантии что ПО не испоганит существующие настройки. Это займет 3 команды на установку в RPM-подобных и 6-7 в deb, плюс риск порчи данных.

2-й вариант получается пакетный менеджер ради пакетного менеджера.
Т.к. его функции только создадут дополнительные шаги.

Соответственно вопрос: Зачем?


На «потестировать» я держу отдельное чистое chroot-окружение, поверх которого перед установкой «свежатинки» монтируется временная файлуха через aufs. Быстро поднимается, нет риска порчи данных. 





Ну а в чём проблема тестирования в изолированном окружении-то? Зачем ставить параллельно со стабильной версией и запускать вместо неё? Давно не играли в русскую рулетку? 

Авторы программ просят начала сделать configure, где можно указать префикс
configure --prefix = /usr/local после этих действий будет Makefaile,
где описан процесс сборки и установки и деинсталляции,
так что потом можно легко сделать make uninstall.
А ставить в бинарный дистр в /bin /usr/bin, самосбор — дурной тон :) получается действительно каша.

И все таки рекомендую почитать доку по LFS и GNU configure and build system.
Там еще очень много интересного :) 





 Спасибо за минус в карму. Подавитесь. Толковую литературу читать вы тоже не собираетесь — отлично. А с какого перепугу вы решили, что то, что не контролирует пакетный менеджер — хлам? Каждый пользователь сам в ответе за свои действия, если он не понимает как работает make и что такое Makefile — это его проблемы. К тому-же ваши «советы» применимы только к deb-based бистрибутивам. То есть вы даете «подоконные» советы — вы рассказываете готовый рецепт о том как нужно делать в данном конкретном случае, применимом к нескольким дистрибутивам, вместо того, чтобы познакомить новичков с основами и прояснить им суть сборки пакетов из исходников.
Раз: директория /opt предназначена как раз для самосборных сложных програм, тоесть создаем там, например, /opt/kde и делаем make install --prefix=/opt/kde, после чего получаем собранный, работоспособный, большой пакет, который в случае чего можно без проблем удалить.
Два: /usr/local — аналог / для маленького самосбора, который можно без проблем повычищать руками из поддиректорий.
Три: предложенный вами вариант неплох, но он не всегда удобен и работает далеко не везде. 




    Спасибо за минус в карму. Подавитесь

Эм. Вы меня с кем-то спутали. Я минусов в карму за мнение, отличающееся от моего никогда не ставлю. Как писал Вольтер, «мне ненавистны ваши убеждения, но я готов отдать жизнь за ваше право их высказывать».

    если он не понимает как работает make и что такое Makefile — это его проблемы.

Это не повод создавать проблемы тем, кому адресуется статья про установку %softwarename% на %distroname%.

    К тому-же ваши «советы» применимы только к deb-based бистрибутивам. 

Они применимы ко всему, что использует бинарные пакеты.

    Раз: директория /opt предназначена как раз для самосборных сложных програм, тоесть создаем там, например, /opt/kde и делаем make install --prefix=/opt/kde, после чего получаем собранный, работоспособный, большой пакет, который в случае чего можно без проблем удалить.

Я уже, кажется, писал, что софтина может ожидать того, что там, куда её ставят, её увидит кто-то ещё. Даже пример с /usr/share/xsessions привёл. Иногда установщики могут что-то в /etc/modprobe.d добавлять.

    Два: /usr/local — аналог / для маленького самосбора, который можно без проблем повычищать руками из поддиректорий.

Вы сейчас призываете к тому, что противоречит самой идее, ради которой создавались ЭВМ — автоматизировать всё то, что можно автоматизировать.






 А что мешает устанавливать с помощью

./configure --prefix=/home/%username%/
make install
0
andrewsch, 21 октября 2011 в 22:18 #
↵
↑
Да, на самом деле — я, к примеру, все, что не устанавливается автоматически apt-get-ом, спокойно ставлю в /opt/product_name-version/ и все. Потом это сносится простым удалением каталога.

Понятно, что голый «make install» бесконтрольно замусоривает систему. Об этом просто нужно знать (ну, обучать там), а если всех расстреливать за незнание — люди быстро кончатся :) 












Например, я собираю программу из исходников, запускаю дефолтный «make install», и он записывает часть файлов в /etc, часть в /usr/local/lib, часть в /var, часть еще фиг знает куда.

Я мог-бы запустить «make uninstall», но в 99% случаев исходники вместе со всеми временными файлами удаляются после сборки. Так что корректно де-инсталлировать уже ничего нельзя.

Поэтому, как автор статьи и написал, нужно ставить софт из стандартных репозиториев, которые отслеживают зависимости и корректно обновляют пакеты.
Или, если стандартный репозиторий не подходит, ставить в выделенный каталог в /opt, чтобы удалять простым одним движением — точно как вы написали :-)

Так что статья вполне имеет право на жизнь, в качестве ликбеза. 













 Хм… На сервере установлен php 5.2, мне нужно установить 5.3, но 5.2 не должен быть удален! Как быть? :)
–5
BVN2, 21 октября 2011 в 18:44 #
↵
↑
Если вам нужно ставить два языка на один и тот же сервер — то это фантазии. С таким же успехом можно пытаться тратить деньги и при чём, что бы они сохранялись.

Если нужно на одну и туже машину поставить php двух версий, то ставьте ещё один апач (или какой-либо другой сервер) и цепляйте к нему php 5.2.
–2
BVN2, 21 октября 2011 в 18:49 #
↵
↑
Извиняюсь
— не два языка, а две ПХП'шки
— … и цепляйте к нему php 5.3
0
Pokoinik, 21 октября 2011 в 18:54 #
↵
↑
Молодой человек, большинство шаред хостингов могут вам предоставить на одним и том же сервере php 5.2 и 5.3 одновременно.

Более того, при желании сюда можно воткнуть еще и пых четвертой ветки, для особых извращений.
0
kekekeks, 21 октября 2011 в 18:45 #
↵
↑
Выставить префиксом /opt/newphp, далее по инструкции. После чего сами разбираетесь с тем, как и куда его прописать, чтобы веб-сервер увидел. 







 А почему не /usr/local
ведь папка пустая же в большинстве дистрибутивов,
но в отличии от /opt/newphp/bin/ /usr/local/bin уже есть в переменной path
0
kekekeks, 21 октября 2011 в 19:02 #
↵
↑
И какой из бинарников будет запускаться из консоли? Нет уж, мухи отдельно, котлеты отдельно.
0
anycolor, 22 октября 2011 в 06:25 #
↵
↑
тот, к которому пропишите полный путь :) Не поддерживаю /usr/local идею, просто мимо проходил. 







В Gentoo можно использовать слоты и переключаться между версиями при необходимости.

Удобно бывает. 







я еще бы посоветовал бы так сначала

sudo auto-apt update && auto-apt -y run ./configure



Команда auto-apt автоматом будет доставлять пакеты с необходимыми файлами, всякие там заголовочные файлы .h подробнее 5.3 Установка пакетов «по запросу»
Этот шаг позволит автоматически удовлетворить зависимости компилируемой программы и меньше будете пытать людей на форумах, типа чего надобно программе на слове stdio.h NOT FOUND

потом

checkinstall -D
















Downgrade
[http://ru.ispdoc.com/index.php/%D0%9E%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_PHP_%D0%B2_CentOS_Linux](http://ru.ispdoc.com/index.php/%D0%9E%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_PHP_%D0%B2_CentOS_Linux)

[http://forum.searchengines.ru/showthread.php?t=522085](http://forum.searchengines.ru/showthread.php?t=522085)
[http://askubuntu.com/questions/138284/how-to-downgrade-a-package-via-apt-get](http://askubuntu.com/questions/138284/how-to-downgrade-a-package-via-apt-get)
[http://dustyreagan.com/downgrade-php-5-3-to-5-2/](http://dustyreagan.com/downgrade-php-5-3-to-5-2/)
[http://serverfault.com/questions/274310/how-do-i-downgrade-an-rpm](http://serverfault.com/questions/274310/how-do-i-downgrade-an-rpm)
[http://siliconrealms.org/content/view/8/18/](http://siliconrealms.org/content/view/8/18/)
[http://www.linuxjournal.com/article/7034](http://www.linuxjournal.com/article/7034)
[http://docs.fedoraproject.org/en-US/Fedora/14/html/Software_Management_Guide/ch05s06s03.html](http://docs.fedoraproject.org/en-US/Fedora/14/html/Software_Management_Guide/ch05s06s03.html)
[http://superuser.com/questions/261115/how-to-downgrade-and-remove-rpms-in-the-same-command](http://superuser.com/questions/261115/how-to-downgrade-and-remove-rpms-in-the-same-command)
[http://www.linuxjournal.com/node/7034/print](http://www.linuxjournal.com/node/7034/print)
[http://www.if-not-true-then-false.com/2010/yum-downgrade-packages-on-fedora-centos-red-hat-rhel/](http://www.if-not-true-then-false.com/2010/yum-downgrade-packages-on-fedora-centos-red-hat-rhel/)
[http://blog.adityapatawari.com/2012/05/how-to-downgrade-or-reinstall-rpm.html](http://blog.adityapatawari.com/2012/05/how-to-downgrade-or-reinstall-rpm.html)
[http://www.sohailriaz.com/how-to-downgrade-rpm-package-using-yum/](http://www.sohailriaz.com/how-to-downgrade-rpm-package-using-yum/)